Implementacion Lolla:

    Interfaz: 

        IniciarLolla(in puestos: dicc(puestoid, puesto), in personas: conj(persona)) -> res:Lolla

            pre:{!vacio?(personas) & !vacio?(claves(puestos)) & vendenAlMismoPrecio(significados(puestos)) & noVendieronAun(significados(puestos))}
            post:{crearLolla(puestos, personas) = res}
            Complejidad:
            Aliasing:
            Descripcion: Dados un conjunto de personas y puestos crea un Lolla. 

        Vender(inout l: lolla, in pid: puestoId, in p: persona, in i: item, in cant: cantidad)
            
            pre:{l = l0 & obtener(pid, puestos(l)) e puestos(l) & p e personas(l) 
                & item e menu(obtener(pid, puestos(l))) & haySuficiente?(obtener(pid, puestos(l)), i, cant)}
            post:{l = vender(l0, pid, p, i, cant)}
            Complejidad: O(log(A) + log(I) + log(P) + log(cant))
            Aliasing:
            Descripcion: Dados un lolla, un id de un puesto, una persona, un item y una cantidad...

        HackearLolla(inout l: lolla, in p: persona, in i: item)

            pre:{l = l0 & p e personas(l) & consumioSinPromoEnAlgunPuesto(l, p, i)}
            post:{l = hackear(l0, p, i)}
            Complejidad: O(log(A) + log(I)) || O(log(A) + log(I) + log(P))
            Aliasing: 
            Descripcion: Dado un lolla, una persona valida y un item. Si la persona consumio ese item sin descuento, se le resta una unidad
            de ese item al consumo de la persona y se repone el stock del puesto en el cual se produjo la venta.

        VerPuestos(in l: lolla) -> res = dicc(puestoId, puesto)

            pre:{true}
            post:{res = puestos(l)}
            Complejidad: O(1)
            Aliasing:
            Descripcion: Dado un lolla, retorna un diccionario con sus puestos.

        VerPersonas(in l: lolla) -> res:conj(persona)

            pre:{true}
            post:{res = personas(l)}
            Complejidad: O(1)
            Aliasing: Devuelve una referencia no modificable al conjunto de personas del lolla.
            Descripcion: Dado un lolla, retorna un conjunto con sus personas.

        GastoTotalPersona(in l: lolla, in p: persona) -> res:dinero

            pre:{p e personas(l)}
            post:{res = gastoTotal(l,p)}
            Complejidad: O(log(A))
            Aliasing: Devuelve una copia del gasto total de la persona.
            Descripcion: Dado un lolla y una persona, retorna el gasto total de la persona en el lolla.

        PersonaQueMasGasto(in l: lolla, in ps: conj(persona)) -> res:persona

            pre:{ps = personas(l) && !vacio?(ps)}
            post:{res = masGasto(l)}
            Complejidad: O(1)
            Aliasing: Devuelve una copia de la persona que mas gasto.
            Descripcion: Dado un lolla y un conjunto de personas, todas pertenecientes al lolla devuelve la que mas gasto.

        MenorStock(in l: lolla, in i: item) -> res: puestoId 

            pre:{ExistePuestoConStock(puestos(l), i)} //Habria que hacer este predicado auxiliar.
            post:{res = menorStock(l, i)}
            Complejidad: //No hay restriccion
            Aliasing:
            Descripcion: Dado un lolla y un item retorna el puesto que tiene menor stock de ese item.

    Representacion:

        Lolla se representa con estr donde 
            estr = <
                    puestos: diccLog(puestoId, puesto),
                    personas: conjLog(persona),
                    gastosPersonas: diccLog(persona, nat),
                    // comprasSinDescuentoPorPersona: diccLog(persona, diccLog(item, secu(puestoId))),
                    personaQueMasGasto: persona
                   >
    Algoritmos:
        iIniciarLolla(in puestos: dicc(puestoid, puesto), in personas: conj(persona)) -> res: Lolla { //O(A) + O(P)

            estr.puestos = puestos; //O(P) donde P es la cantidad de claves de puestos(ids).
            estr.personas = personas; //O(A) donde A es la cardinalidad del conjunto(personas).
            estr.gastosPersonas = Vacio();
            estr.personaQueMasGasto = 0; //O(1) 0 es un placeholder hasta que haya al menos 1 compra en todo el lolla.
        }

        iVender(inout l: lolla, in pid: puestoId, in p: persona, in i: item, in cant: cantidad) { //O(log(A) + log(I) + log(P) + log(Cant)) donde A es la cantidad de personas, I la cantidad de items, P la cantidad de puestos y Cant es la máxima cantidad adquirida.
            
            puesto = significado(estr.puestos, puestoId); //O(log(P)) Donde P es la cantidad de puestos.

            Vender(puesto, p, i, cant); //O(log(I) + log(Cant) + log(A)) donde A es la cantidad de Personas, I es la cantidad de items y Cant es la cantidad Máxima.

            gasto = CalcularGasto(puesto, i, cant); //O(log(I) + log(Cant))

            if(!definido(estr.gastosPersonas, p)){ //O(log(A))

                definir(estr.gastosPersonas, p, gasto); //O(log(A))
            }

            else{

                definir(estr.gastosPersonas, p, significado(estr.gastosPersonas, p) + gasto); //O(log(A))
            }

            if(significado(estr.gastosPersonas, p) >= significado(estr.gastosPersonas, estr.personaQueMasGasto)){ //O(log(A))

                if(p > estr.personaQueMasGasto){ //O(1)

                    estr.personaQueMasGasto = p; //O(1)
                }
            }
        }

        iHackearLolla(inout l: lolla, in p: persona, in i: item) {
           

        }

        iVerPuestos(in l: lolla) -> res = dicc(puestoId, puesto) { //O(1)

            puestosLolla = estr.puestos; //O(1)

            return puestosLolla; //O(1)
        }

        iVerPersonas(in l: lolla) -> res = conj(persona){ //O(1)

            personasLolla = estr.personas; //O(1)

            return personasLolla; //O(1)
        }

        iGastoTotalPersona(in l: lolla, in p: persona) -> res = nat { //O(log(A))

            gastoPersona = 0; //O(1)

            if(definido?(estr.gastosPersonas, p)){ //O(log(A))

                gastoPersona = significado(estr.gastosPersonas, p); //O(log(A)) donde A es la cantidad de personas.
            }

            return gastoPersona; //O(1)
        }

        iPersonaQueMasGasto(in l: lolla, in personas: conj(persona)) -> res = persona { //O(1)

            personaQueMasGasto = estr.personaQueMasGasto; //O(1)

            return personaQueMasGasto; //O(1)
        }
        
        // iVerStock(in l: lolla, in p: puesto, in i: item) -> res = nat Esta funcion me parece innecesaria.

        iMenorStock(in l: lolla, in i: item) -> res = puestoId { //O(P) * O(log(I))

            it = crearIt(estr.puestos); //O(1)
            menorStock = <SiguienteClave(it), SiguienteSignificado(it)>; //O(1)

            while(HaySiguiente(it)){ // O(P) O(log(I)) donde P es la cantidad de puestos.

                if(verStock(SiguienteSignificado(it), i) <= pi1(menorStock)){ //O(log(I)) donde I es la cantidad de items.

                    if(SiguienteClave(it) < pi0(menorStock)){ //O(1)

                        menorStock = <SiguienteClave(it), SiguienteSignificado(it)> //O(1)
                    }

                    else{ //O(1)

                        menorStock = <SiguienteClave(it), SiguienteSignificado(it)> //O(1)
                    }
                }

                Avanzar(it); //O(1)
            }

            return pi0(menorStock); //O(1)
        } 


Implementacion Puesto:

    Interfaz:

        CrearPuesto(in precios: dicc(item, nat), in stock: dicc(item, nat), in desc: dicc(item, dicc(cant, nat))) -> res: puesto

            pre:{claves(precios) = claves(stock) && claves(desc) C claves(precios)}
            post:{crearPuesto(precios, stock, desc) = res}
            Complejidad:
            Aliasing: -
            Descripcion: Genera un nuevo puesto de comida.

        Vender(inout pdc: puesto, in p: persona, in i: item, in cant: cantidad)

            pre:{pdc = pdc0 && i e menu(pdc) &&L stock(pdc,i) >= cant} //Aca tenes que pedir si o si que el item este en el menu sino se indefine stock(pdc,i).
            post:{pdc = vender(pdc0,p,i,cant)}
            Complejidad: O(log(I) + log(cant) + log(P)) donde I es la cantidad de items, cant son las cantidades en descuentos y P la cantidad de Personas. //El algoritmo tiene que tener en cuenta el precio de registrar una venta en el lolla
            Aliasing: Devuelve una referencia no modificable. //Para mi no hay aliasing acá y no se devuelve ninguna referencia.
            Descripcion: Registra una venta en el puesto.

        verMenu(in pdc: puesto) -> res = conj(item)

            pre:{true}
            post:{res = menu(pdc)}
            Complejidad: O(I) Donde I es la cantidad de Items en el menu //O(1)?? Porque queremos que este en O(1)??
            Aliasing: Devuelve una copia del conjunto de items del menu.
            Descripcion: Retorna el menu del puesto.

        verPrecio(in pdc: puesto, in i: item) -> res:dinero

            pre:{i e menu(pdc)}
            post:{precio(pdc,i) = res}
            Complejidad: O(log(I)) donde I es la cantidad de items.
            Aliasing: Devuelve una copia del precio del item.
            Descripcion: Retorna el precio del item en el puesto.

        verStock(in pdc: puesto, in i: item) -> res:nat

            pre:{i e menu(pdc)}
            post:{obtener(i, stock(pdc)) = res}
            Complejidad: O(log(I)) donde I es la cantidad de items.
            Aliasing: Devuelve una copia del stock del item.
            Descripcion: Retorna el stock del item en el puesto.

        verDescuento(in pdc: puesto, in i: item, in cant: cantidad) -> res: nat

            pre:{i e menu(pdc)}
            post:{res = descuento(pdc,i,cant)} 
            Complejidad: O(log(I) + log(cant)) donde I es la cantidad de items y cant son las cantidades en descuentos.
            Aliasing: Devuelve una copia del descuento del item.
            Descripcion: Retorna el descuento del item en el puesto.

        gastosEnPuesto(in pdc: puesto, in p: persona) -> res: dinero

            pre:{true}
            post:{res = gastosDe(pdc, p)}
            Complejidad: O(log(A))
            Aliasing:
            Descripcion: Retorna el gasto total de una persona en el puesto.

        calcularGasto(in pdc: puesto, in i:item, in cant: cantidad) -> res: dinero

            pre:{true}
            post:{res = gastosDe1Venta(pdc, (i, cant))}
            Complejidad: O(log(I) + log(cant)) donde I es la cantidad de items y cant son las cantidades en descuentos.
            Aliasing: -
            Descripcion: Devuelve el precio de una venta.
    
    Representacion:
            
            Puesto se representa con estr donde
                estr = <
                        precios: dicclog(item, nat),
                        stock: dicclog(item, nat),
                        descuentos: dicclog(item, dicc(cantidad, nat)),
                        rangosDescuentosxItem: diccLog(item, vector(cantidad)), 
                        ventas: dicclog(persona, listaEnlazada(tupla(item, cantidad))), //Considerar dicLog(item, nat).
                        //VentasSinPromo: diccLog(persona, dicLog())
                        gastoTotal: dicclog(persona, nat)
                        >

    Algoritmos:

        iCrearPuesto(in precios: dicc(item, nat), in stock: dicc(item, nat), in desc: dicc(item, dicc(cant, nat))) -> res:puesto { //O(log(I)) * D * J * E. Donde I es la cant de claves de precios/Stock, D es la cantidad de descuentos y E es la longitud del vector rangos.

                estr.precios = precios; //O(I)
                estr.stock = stock; //O(I)
                estr.descuentos = desc; //O(m) //m son las claves de desc (#menor o igual a las de precios/stock), en el peor caso es igual a O(I) cuando todos los elementos tienen descuentos.
                estr.rangosDescuentosxItem = Vacio(); //O(1)
                estr.ventas = Vacio(); //O(1)
                estr.gastoTotal = Vacio(); //O(1)

                itDescuentos = crearIt(estr.descuentos); //O(1)
            
                while(HaySiguiente(itDescuentos)){ //O(log(I) * D * J * E) donde D es la cantidad de descuentos y E es la longitud del vector rangos.
                    
                    item =  SiguienteClave(itDescuentos); //O(1)
                    definir(estr.rangosDescuentosxItem, item, Vacia()); //O(log(I))
                    itCantDescuentos = crearIt(significado(estr.descuentos, item)); //O(log(I))
                    vectorRangosCantidad = significado(estr.rangosCantidad, item); //O(log(I))
                    j = 0; //O(1)

                    while(HaySiguiente(itCantDescuentos)){ //O(D * J * E)

                        cantidad = SiguienteClave(itCantDescuentos); //O(1) Asumo que las cantidades van de menor a mayor(es decir si tengo descuentos por 5, 10 y 3 cantidades al iterar recorreria 3, luego 5 y por último 10).

                        for(j, j <= cantidad, j++){ //O(J * E)
 
                            AgregarAtras(vectorRangosCantidad, cantidad); //O(E)
                        }

                        Avanzar(itCantDescuentos); //O(1)
                    }

                    Avanzar(itDescuentos); //O(1)
                }
            }

        iVender(inout pdc: puesto, in p: persona, in i: item, in cant: cantidad) {//O(log(I) + log(Cant) + log(A))

                nuevoGasto = CalcularGasto(pdc, i, cant); //O(log(I) + log(Cant)) donde I es la cantidad de items y Cant es la cantidad de promociones.
                
                if(definido?(estr.ventas, p)){ //O(log(A))

                    AgregarAdelante(significado(estr.ventas, p), (i, cant)); //O(log(A)) donde A es cantidad de claves de ventas.
                    definir(estr.gastoTotal, p, significado(p, estr.gastoTotal) + nuevoGasto); //O(log(m)) donde m es cantidad de claves de gastoTotal. Pero como la cantidad de claves es la misma que la de ventas queda O(log(A)). Son iguales dado que si se hace una venta hay un gasto asociado.
                }

                else{

                    definir(estr.ventas, p, Vacio()); //O(log(A)) donde A es cantidad de claves de ventas.
                    AgregarAdelante(significado(estr.ventas, p), (i, cant)); //O(log(A))
                    definir(estr.gastoTotal, p, nuevoGasto); //O(log(m)) donde m es cantidad de claves de gastoTotal. Pero como la cantidad de claves es la misma que la de ventas queda O(log(A)).
                }

                definir(estr.stock, i, significado(estr.stock, i) - cant); //O(log(I)) donde I es cantidad de claves de stock.
        }

        iVerMenu(in pdc: puesto) -> res:conj(item) { //O(I)

            it = crearIt(estr.precios); //O(1)
            items = Vacio(); //O(1)

            while(HaySiguiente(it)){ //O(I) donde I es la cantidad de claves en precios.

                AgregarRapido(SiguienteClave(it)); //O(1)
            }

            return items; //O(1)
        }

        iVerPrecio(in pdc: puesto, in i: item) -> res:nat { //O(log(I))

            precioItem = significado(estr.precios, i); //O(log(I)) donde I es la cantidad de claves en precios(items).

            return precioItem; //O(1)
        }

        iVerStock(in pdc: puesto, in i: item) -> res:nat { //O(log(I))

            stockItem = significado(estr.stock, i); //O(log(I)) donde I es la cantidad de claves en stock(items)
            
            return stockItem; //O(1)
        }

        iVerDescuento(in pdc: puesto, in i: item, in cant: cantidad) -> res:nat { //O(log(I) + log(Cant)) donde I es la cantidad de elementos y Cant es la cantidad máxima.

        
           if(!definido?(estr.descuentos, i)) { //O(log(I))

                return 0;
            }

            descuentos = significado(estr.descuentos, i); //O(log(I))
            rangoDescuentos = significado(estr.rangosDescuentosxItem, i); //O(log(I)) en el peor caso tengo tantos descuentos como variedades de items tenga.

           if(Primero(rangoDescuentos) <= cant <= Ultimo(rangoDescuentos)){ //O(log(Cant))

                claveCantidad = rangoDescuentos[cant]; //O(1)
                return Significado(descuentos, claveCantidad); //O(log(Cant))
           }

           else if(cant > Ultimo(rangoDescuentos)){ //O(log(Cant))

                claveCantidad = Ultimo(rangoDescuentos) //O(1)
                return Significado(descuentos, claveCantidad); //O(log(Cant))
           }

           return 0; //O(1)
        }

        iGastosEnPuesto(in pdc: puesto, in p: persona) -> res:nat { //O(log(A))

            gastoPersona = 0; //O(1)

            if(definido?(estr.gastoTotal, p)){ //O(log(A))

                gastoPersona = significado(estr.gastoTotal, p); //O(log(A)) donde A es la cantidad de claves en gastoTotal(personas)
            }

            return gastoPersona; //O(1)
        }

        iCalcularGasto(in pdc: puesto, in i: item, in cant: cantidad) -> res:nat { //O(log(I) + log(Cant))

            total = significado(estr.precios, i) * cant; //O(log(I) + log(Cant)) donde I es la cantidad de claves de precios y Cant es la cantidad de descuentos.
            descuento = verDescuento(pdc, i, cant); //O(log(I) + log(Cant))

            if(descuento != 0){ //O(1)

                return total * descuento; //O(1)
            }

            return total; //O(1)
        }