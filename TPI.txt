Implementacion Lolla:

    Interfaz: 

        IniciarLolla(in puestos: dicc(puestoid, puesto), in personas: conj(persona)) -> res:Lolla

            pre:{!vacio?(personas) & !vacio?(claves(puestos)) & vendenAlMismoPrecio(significados(puestos)) & noVendieronAun(significados(puestos))}
            post:{crearLolla(puestos, personas) = res}
            Complejidad:
            Aliasing:
            Descripcion: Dados un conjunto de personas y puestos crea un Lolla.
            

        Vender(inout l: lolla, in pid: puestoId, in p: persona, in i: item, in cant: cantidad)
            
            pre:{l = l0 & obtener(pid, puestos(l)) e puestos(l) & p e personas(l) 
                & item e menu(obtener(pid, puestos(l))) & haySuficiente?(obtener(pid, puestos(l)), i, cant)}
            post:{l = vender(l0, pid, p, i, cant)}
            Complejidad: O(log(A) + log(I) + log(P) + log(cant))
            Aliasing:
            Descripcion: Dados un lolla, un id de un puesto, una persona, un item y una cantidad...

        HackearLolla(inout l: lolla, in p: persona, in i: item)

            pre:{l = l0 & p e personas(l) & item & consumioSinPromoEnAlgunPuesto(l, p, i)}
            post:{l = hackear(l0, p, i)}
            Complejidad: O(log(A) + log(I)) || O(log(A) + log(I) + log(P))
            Aliasing:
            Descripcion: Dado un lolla, una persona valida y un item. Si la persona consumio ese item sin descuento, se le resta una unidad
            de ese item al consumo de la persona y se repone el stock del puesto en el cual se produjo la venta.

        VerPuestos(in l: lolla) -> res = dicc(puestoId, puesto)

            pre:{true}
            post:{res = puestos(l)}
            Complejidad: O(1)
            Aliasing:
            Descripcion: Dado un lolla, retorna un diccionario con sus puestos.

        VerPersonas(in l: lolla) -> res:conj(persona)

            pre:{true}
            post:{res = personas(l)}
            Complejidad: O(1)
            Aliasing: Devuelve una referencia no modificable al conjunto de personas del lolla.
            Descripcion: Dado un lolla, retorna un conjunto con sus personas.

        GastoTotalPersona(in l: lolla, in p: persona) -> res:dinero

            pre:{p e personas(l)}
            post:{res = gastoTotal(l,p)}
            Complejidad: O(log(A))
            Aliasing: Devuelve una copia del gasto total de la persona.
            Descripcion: Dado un lolla y una persona, retorna el gasto total de la persona en el lolla.

        PersonaQueMasGasto(in l: lolla, in ps: conj(persona)) -> res:persona

            pre:{ps = personas(l) && !vacio?(ps)}
            post:{res = masGasto(l)}
            Complejidad: O(1)
            Aliasing: Devuelve una copia de la persona que mas gasto.
            Descripcion: Dado un lolla y un conjunto de personas, todas pertenecientes al lolla devuelve la que mas gasto.

        //No se si es necesario
        // verStock(in l: lolla, in p: puesto, in i: item) -> res = nat

        //     pre:{p e puestos(l) && i e menu(p)}
        //     post:{}
        //     Complejidad:
        //     Aliasing:
        //     Descripcion: Dado un lolla, un puesto perteneciente y un item devuelve su stock en ese puesto.

        MenorStock(in l: lolla, in i: item) -> res: puestoId 

            pre:{ExistePuestoConStock(puestos(l), i)} //Habria que hacer este predicado auxiliar.
            post:{res = menorStock(l, i)}
            Complejidad: //No hay restriccion
            Aliasing:
            Descripcion: Dado un lolla y un item retorna el puesto que tiene menor stock de ese item.

    Representacion:

        Lolla se representa con estr donde 
            estr = <
                    puestos: diccLog(puestoId, puesto),
                    personas: conjLog(persona), //Convendra tenerlas en un heap? para poder sacar el maximo facilmente?
                    personasPorDinero: diccHeap(persona,dinero)
                    >
    Algoritmos:
        iIniciarLolla(in puestos: dicc(puestoid, puesto), in personas: conj(persona)) -> res: Lolla
        iVender(inout l: lolla, in pid: puestoId, in p: persona, in i: item, in cant: cantidad)
        iHackearLolla(inout l: lolla, in p: persona, in i: item)
        iVerPuestos(in l: lolla) -> res = dicc(puestoId, puesto)
        iVerPersonas(in l: lolla) -> res = conj(persona)
        iGastoTotalPersona(in l: lolla, in p: persona) -> res = nat
        iPersonaQueMasGasto(in l: lolla, in personas: conj(persona)) -> res = persona
        iVerStock(in l: lolla, in p: puesto, in i: item) -> res = nat
        iMenorStock(in l: lolla, in i: item) -> res = puestoId 

Implementacion Puesto:

    Interfaz:

        CrearPuesto(in precios: dicc(item, nat), in stock: dicc(item, nat), in desc: dicc(item, dicc(cant, nat))) -> res: puesto

            pre:{claves(precios) = claves(stock) && claves(desc) C claves(precios)}
            post:{crearPuesto(precios, stock, desc) = res}
            Complejidad:
            Aliasing:
            Descripcion: Genera un nuevo puesto de comida.

        Vender(inout pdc: puesto, in p: persona, in i: item, in cant: cantidad)

            pre:{pdc = pdc0 && stock(pdc,i) >= cant}
            post:{pdc = vender(pdc0,p,i,cant)}
            Complejidad: //El algoritmo tiene que tener en cuenta el precio de registrar una venta en el lolla
            Aliasing: Devuelve una referencia no modificable. 
            Descripcion: Registra una venta en el puesto.

        verMenu(in pdc: puesto) -> res = conj(item)

            pre:{true}
            post:{res = menu(pdc)}
            Complejidad: O(1) //Va a estar guardado en la estructura
            Aliasing: Devuelve una copia del conjunto de items del menu.
            Descripcion: Retorna el menu del puesto.

        verPrecio(in pdc: puesto, in i: item) -> res:dinero

            pre:{i e menu(pdc)}
            post:{precio(pdc,i) = res}
            Complejidad: O(log(I))
            Aliasing: Devuelve una copia del precio del item.
            Descripcion: Retorna el precio del item en el puesto.

        verStock(in pdc: puesto, in i: item) -> res:nat

            pre:{i e menu(pdc)}
            post:{obtener(i, stock(pdc)) = res}
            Complejidad: O(log(I))
            Aliasing: Devuelve una copia del stock del item.
            Descripcion: Retorna el stock del item en el puesto.

        verDescuento(in pdc: puesto, in i: item, in cant: cantidad) -> res: dinero

            pre:{i e menu(pdc)}
            post:{res = descuento(pdc,i,cant)} 
            Complejidad: O(log(I) + log(cant))
            Aliasing: Devuelve una copia del descuento del item.
            Descripcion: Retorna el descuento del item en el puesto.

        stockSuficiente(in pdc: puesto, in i: item, in cant: cantidad) -> res: bool

            pre:{i e menu(pdc)}
            post:{res = stock(pdc, i) >= cant}
            Complejidad:
            Aliasing:
            Descripcion: Retorna si hay stock suficiente del item en el puesto.

        huboDescuento?(in pdc: puesto, in p: persona, in i: item) -> res: bool

            pre:{i e menu(pdc)}
            post:{res = (existe c:nat)(existe t:tupla<item,c>)(t e ventas(pdc, p) y ¿t[0] = i? ¿=>L? descuento(pdc, i, c)=t[1])} // Me fijo si se hizo una venta de el item y si se hizo, fijarme si la cant que vendi es igual a alguno de los descuento que tiene ese producto
            Complejidad:
            Aliasing: Como devuelte un bool, no hay aliasing.
            Descripcion: Retorna si hubo descuento o no durante la venta del item en el puesto.

        gastosEnPuesto(in pdc: puesto, in p: persona) -> res: dinero

            pre:{}
            post:{}
            Complejidad: O(log(A))
            Aliasing:
            Descripcion: Retorna el gasto total de una persona en el puesto.
    
    Representacion:
            
            Puesto se representa con estr donde
                estr = <
                        menu: dicc(item, nat),
                        precios: dicc(item, nat),
                        stock: dicc(item, nat),
                        descuentos: dicc(item, dicc(cant, nat)),
                        ventas: dicc(persona, dicc(item, nat)),
                        gastoTotal: dicc(persona, nat),
                        >

    Algoritmos:
        iCrearPuesto(in precios: dicc(item, nat), in stock: dicc(item, nat), in desc: dicc(item, dicc(cant, nat))) -> res:puesto
        iVender(inout pdc: puesto, in p: persona, in i: item, in cant: cantidad)
        iVerMenu(in pdc: puesto) -> res:conj(item)
        iVerPrecio(in pdc: puesto, in i: item) -> res:nat
        iVerStock(in pdc: puesto, in i: item) -> res:nat
        iVerDescuento(in pdc: puesto, in i: item, in cant: cantidad) -> res:nat
        iStockSuficiente(in pdc: puesto, in i: item, in cant: cantidad) -> res:bool
        iHuboDescuento(in pdc: puesto, in p: persona, in i: item) -> res:bool
        iGastosEnPuesto(in pdc: puesto, in p: persona) -> res:nat